// Code generated by goa v3.21.5, DO NOT EDIT.
//
// mailing-list HTTP client CLI support package
//
// Command:
// $ goa gen
// github.com/linuxfoundation/lfx-v2-mailing-list-service/cmd/mailing-list-api/design

package client

import (
	"encoding/json"
	"fmt"
	"unicode/utf8"

	mailinglist "github.com/linuxfoundation/lfx-v2-mailing-list-service/gen/mailing_list"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateGrpsioServicePayload builds the payload for the mailing-list
// create-grpsio-service endpoint from CLI flags.
func BuildCreateGrpsioServicePayload(mailingListCreateGrpsioServiceBody string, mailingListCreateGrpsioServiceVersion string, mailingListCreateGrpsioServiceBearerToken string) (*mailinglist.CreateGrpsioServicePayload, error) {
	var err error
	var body CreateGrpsioServiceRequestBody
	{
		err = json.Unmarshal([]byte(mailingListCreateGrpsioServiceBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"auditors\": [\n         \"auditor_user_id1\",\n         \"auditor_user_id2\"\n      ],\n      \"domain\": \"lists.project.org\",\n      \"global_owners\": [\n         \"admin@example.com\"\n      ],\n      \"group_id\": 12345,\n      \"group_name\": \"project-name\",\n      \"prefix\": \"formation\",\n      \"project_slug\": \"cncf\",\n      \"project_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"public\": true,\n      \"status\": \"created\",\n      \"type\": \"primary\",\n      \"url\": \"https://lists.project.org\",\n      \"writers\": [\n         \"manager_user_id1\",\n         \"manager_user_id2\"\n      ]\n   }'")
		}
		if !(body.Type == "primary" || body.Type == "formation" || body.Type == "shared") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"primary", "formation", "shared"}))
		}
		for _, e := range body.GlobalOwners {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.global_owners[*]", e, goa.FormatEmail))
		}
		if body.ProjectSlug != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.project_slug", *body.ProjectSlug, goa.FormatRegexp))
		}
		if body.ProjectSlug != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.project_slug", *body.ProjectSlug, "^[a-z][a-z0-9_\\-]*[a-z0-9]$"))
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", body.ProjectUID, goa.FormatUUID))
		if body.URL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.url", *body.URL, goa.FormatURI))
		}
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if mailingListCreateGrpsioServiceVersion != "" {
			version = &mailingListCreateGrpsioServiceVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if mailingListCreateGrpsioServiceBearerToken != "" {
			bearerToken = &mailingListCreateGrpsioServiceBearerToken
		}
	}
	v := &mailinglist.CreateGrpsioServicePayload{
		Type:        body.Type,
		Domain:      body.Domain,
		GroupID:     body.GroupID,
		Status:      body.Status,
		Prefix:      body.Prefix,
		ProjectSlug: body.ProjectSlug,
		ProjectUID:  body.ProjectUID,
		URL:         body.URL,
		GroupName:   body.GroupName,
		Public:      body.Public,
	}
	if body.GlobalOwners != nil {
		v.GlobalOwners = make([]string, len(body.GlobalOwners))
		for i, val := range body.GlobalOwners {
			v.GlobalOwners[i] = val
		}
	}
	{
		var zero bool
		if v.Public == zero {
			v.Public = false
		}
	}
	if body.Writers != nil {
		v.Writers = make([]string, len(body.Writers))
		for i, val := range body.Writers {
			v.Writers[i] = val
		}
	}
	if body.Auditors != nil {
		v.Auditors = make([]string, len(body.Auditors))
		for i, val := range body.Auditors {
			v.Auditors[i] = val
		}
	}
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetGrpsioServicePayload builds the payload for the mailing-list
// get-grpsio-service endpoint from CLI flags.
func BuildGetGrpsioServicePayload(mailingListGetGrpsioServiceUID string, mailingListGetGrpsioServiceVersion string, mailingListGetGrpsioServiceBearerToken string) (*mailinglist.GetGrpsioServicePayload, error) {
	var err error
	var uid string
	{
		uid = mailingListGetGrpsioServiceUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if mailingListGetGrpsioServiceVersion != "" {
			version = &mailingListGetGrpsioServiceVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if mailingListGetGrpsioServiceBearerToken != "" {
			bearerToken = &mailingListGetGrpsioServiceBearerToken
		}
	}
	v := &mailinglist.GetGrpsioServicePayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdateGrpsioServicePayload builds the payload for the mailing-list
// update-grpsio-service endpoint from CLI flags.
func BuildUpdateGrpsioServicePayload(mailingListUpdateGrpsioServiceBody string, mailingListUpdateGrpsioServiceUID string, mailingListUpdateGrpsioServiceVersion string, mailingListUpdateGrpsioServiceBearerToken string, mailingListUpdateGrpsioServiceIfMatch string) (*mailinglist.UpdateGrpsioServicePayload, error) {
	var err error
	var body UpdateGrpsioServiceRequestBody
	{
		err = json.Unmarshal([]byte(mailingListUpdateGrpsioServiceBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"auditors\": [\n         \"auditor_user_id1\",\n         \"auditor_user_id2\"\n      ],\n      \"domain\": \"lists.project.org\",\n      \"global_owners\": [\n         \"admin@example.com\"\n      ],\n      \"group_id\": 12345,\n      \"group_name\": \"project-name\",\n      \"prefix\": \"formation\",\n      \"project_slug\": \"cncf\",\n      \"project_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"public\": true,\n      \"status\": \"created\",\n      \"type\": \"primary\",\n      \"url\": \"https://lists.project.org\",\n      \"writers\": [\n         \"manager_user_id1\",\n         \"manager_user_id2\"\n      ]\n   }'")
		}
		if !(body.Type == "primary" || body.Type == "formation" || body.Type == "shared") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"primary", "formation", "shared"}))
		}
		for _, e := range body.GlobalOwners {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.global_owners[*]", e, goa.FormatEmail))
		}
		if body.ProjectSlug != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.project_slug", *body.ProjectSlug, goa.FormatRegexp))
		}
		if body.ProjectSlug != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.project_slug", *body.ProjectSlug, "^[a-z][a-z0-9_\\-]*[a-z0-9]$"))
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", body.ProjectUID, goa.FormatUUID))
		if body.URL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.url", *body.URL, goa.FormatURI))
		}
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = mailingListUpdateGrpsioServiceUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if mailingListUpdateGrpsioServiceVersion != "" {
			version = &mailingListUpdateGrpsioServiceVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if mailingListUpdateGrpsioServiceBearerToken != "" {
			bearerToken = &mailingListUpdateGrpsioServiceBearerToken
		}
	}
	var ifMatch *string
	{
		if mailingListUpdateGrpsioServiceIfMatch != "" {
			ifMatch = &mailingListUpdateGrpsioServiceIfMatch
		}
	}
	v := &mailinglist.UpdateGrpsioServicePayload{
		Type:        body.Type,
		Domain:      body.Domain,
		GroupID:     body.GroupID,
		Status:      body.Status,
		Prefix:      body.Prefix,
		ProjectSlug: body.ProjectSlug,
		ProjectUID:  body.ProjectUID,
		URL:         body.URL,
		GroupName:   body.GroupName,
		Public:      body.Public,
	}
	if body.GlobalOwners != nil {
		v.GlobalOwners = make([]string, len(body.GlobalOwners))
		for i, val := range body.GlobalOwners {
			v.GlobalOwners[i] = val
		}
	}
	{
		var zero bool
		if v.Public == zero {
			v.Public = false
		}
	}
	if body.Writers != nil {
		v.Writers = make([]string, len(body.Writers))
		for i, val := range body.Writers {
			v.Writers[i] = val
		}
	}
	if body.Auditors != nil {
		v.Auditors = make([]string, len(body.Auditors))
		for i, val := range body.Auditors {
			v.Auditors[i] = val
		}
	}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v, nil
}

// BuildDeleteGrpsioServicePayload builds the payload for the mailing-list
// delete-grpsio-service endpoint from CLI flags.
func BuildDeleteGrpsioServicePayload(mailingListDeleteGrpsioServiceUID string, mailingListDeleteGrpsioServiceVersion string, mailingListDeleteGrpsioServiceBearerToken string, mailingListDeleteGrpsioServiceIfMatch string) (*mailinglist.DeleteGrpsioServicePayload, error) {
	var err error
	var uid string
	{
		uid = mailingListDeleteGrpsioServiceUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if mailingListDeleteGrpsioServiceVersion != "" {
			version = &mailingListDeleteGrpsioServiceVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if mailingListDeleteGrpsioServiceBearerToken != "" {
			bearerToken = &mailingListDeleteGrpsioServiceBearerToken
		}
	}
	var ifMatch *string
	{
		if mailingListDeleteGrpsioServiceIfMatch != "" {
			ifMatch = &mailingListDeleteGrpsioServiceIfMatch
		}
	}
	v := &mailinglist.DeleteGrpsioServicePayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v, nil
}

// BuildCreateGrpsioMailingListPayload builds the payload for the mailing-list
// create-grpsio-mailing-list endpoint from CLI flags.
func BuildCreateGrpsioMailingListPayload(mailingListCreateGrpsioMailingListBody string, mailingListCreateGrpsioMailingListVersion string, mailingListCreateGrpsioMailingListBearerToken string) (*mailinglist.CreateGrpsioMailingListPayload, error) {
	var err error
	var body CreateGrpsioMailingListRequestBody
	{
		err = json.Unmarshal([]byte(mailingListCreateGrpsioMailingListBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"auditors\": [\n         \"auditor_user_id1\",\n         \"auditor_user_id2\"\n      ],\n      \"committee_filters\": [\n         \"Voting Rep\",\n         \"Alternate Voting Rep\"\n      ],\n      \"committee_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"description\": \"Technical steering committee discussions\",\n      \"group_name\": \"technical-steering-committee\",\n      \"public\": false,\n      \"service_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"subject_tag\": \"[TSC]\",\n      \"title\": \"Technical Steering Committee\",\n      \"type\": \"discussion_moderated\",\n      \"writers\": [\n         \"manager_user_id1\",\n         \"manager_user_id2\"\n      ]\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.group_name", body.GroupName, "^[a-z][a-z0-9-]*[a-z0-9]$"))
		if !(body.Type == "announcement" || body.Type == "discussion_moderated" || body.Type == "discussion_open") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"announcement", "discussion_moderated", "discussion_open"}))
		}
		if body.CommitteeUID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.committee_uid", *body.CommitteeUID, goa.FormatUUID))
		}
		for _, e := range body.CommitteeFilters {
			if !(e == "Voting Rep" || e == "Alternate Voting Rep" || e == "Observer" || e == "Emeritus" || e == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.committee_filters[*]", e, []any{"Voting Rep", "Alternate Voting Rep", "Observer", "Emeritus", "None"}))
			}
		}
		if utf8.RuneCountInString(body.Description) < 11 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", body.Description, utf8.RuneCountInString(body.Description), 11, true))
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.service_uid", body.ServiceUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if mailingListCreateGrpsioMailingListVersion != "" {
			version = &mailingListCreateGrpsioMailingListVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if mailingListCreateGrpsioMailingListBearerToken != "" {
			bearerToken = &mailingListCreateGrpsioMailingListBearerToken
		}
	}
	v := &mailinglist.CreateGrpsioMailingListPayload{
		GroupName:    body.GroupName,
		Public:       body.Public,
		Type:         body.Type,
		CommitteeUID: body.CommitteeUID,
		Description:  body.Description,
		Title:        body.Title,
		SubjectTag:   body.SubjectTag,
		ServiceUID:   body.ServiceUID,
	}
	if body.CommitteeFilters != nil {
		v.CommitteeFilters = make([]string, len(body.CommitteeFilters))
		for i, val := range body.CommitteeFilters {
			v.CommitteeFilters[i] = val
		}
	}
	if body.Writers != nil {
		v.Writers = make([]string, len(body.Writers))
		for i, val := range body.Writers {
			v.Writers[i] = val
		}
	}
	if body.Auditors != nil {
		v.Auditors = make([]string, len(body.Auditors))
		for i, val := range body.Auditors {
			v.Auditors[i] = val
		}
	}
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}
