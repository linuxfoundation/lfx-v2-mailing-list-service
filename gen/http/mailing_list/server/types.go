// Code generated by goa v3.21.5, DO NOT EDIT.
//
// mailing-list HTTP server types
//
// Command:
// $ goa gen
// github.com/linuxfoundation/lfx-v2-mailing-list-service/cmd/mailing-list-api/design

package server

import (
	"unicode/utf8"

	mailinglist "github.com/linuxfoundation/lfx-v2-mailing-list-service/gen/mailing_list"
	goa "goa.design/goa/v3/pkg"
)

// CreateGrpsioServiceRequestBody is the type of the "mailing-list" service
// "create-grpsio-service" endpoint HTTP request body.
type CreateGrpsioServiceRequestBody struct {
	// Service type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Service domain
	Domain *string `form:"domain,omitempty" json:"domain,omitempty" xml:"domain,omitempty"`
	// GroupsIO group ID
	GroupID *int64 `form:"group_id,omitempty" json:"group_id,omitempty" xml:"group_id,omitempty"`
	// Service status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of global owner email addresses (required for primary, forbidden for
	// shared)
	GlobalOwners []string `form:"global_owners,omitempty" json:"global_owners,omitempty" xml:"global_owners,omitempty"`
	// Email prefix (required for formation and shared, forbidden for primary)
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty" xml:"prefix,omitempty"`
	// Project slug identifier
	ProjectSlug *string `form:"project_slug,omitempty" json:"project_slug,omitempty" xml:"project_slug,omitempty"`
	// LFXv2 Project UID
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// Service URL
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// GroupsIO group name
	GroupName *string `form:"group_name,omitempty" json:"group_name,omitempty" xml:"group_name,omitempty"`
	// Whether the service is publicly accessible
	Public *bool `form:"public,omitempty" json:"public,omitempty" xml:"public,omitempty"`
	// Manager user IDs who can edit/modify this service
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
	// Auditor user IDs who can audit this service
	Auditors []string `form:"auditors,omitempty" json:"auditors,omitempty" xml:"auditors,omitempty"`
}

// UpdateGrpsioServiceRequestBody is the type of the "mailing-list" service
// "update-grpsio-service" endpoint HTTP request body.
type UpdateGrpsioServiceRequestBody struct {
	// Service type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Service domain
	Domain *string `form:"domain,omitempty" json:"domain,omitempty" xml:"domain,omitempty"`
	// GroupsIO group ID
	GroupID *int64 `form:"group_id,omitempty" json:"group_id,omitempty" xml:"group_id,omitempty"`
	// Service status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of global owner email addresses (required for primary, forbidden for
	// shared)
	GlobalOwners []string `form:"global_owners,omitempty" json:"global_owners,omitempty" xml:"global_owners,omitempty"`
	// Email prefix (required for formation and shared, forbidden for primary)
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty" xml:"prefix,omitempty"`
	// Project slug identifier
	ProjectSlug *string `form:"project_slug,omitempty" json:"project_slug,omitempty" xml:"project_slug,omitempty"`
	// LFXv2 Project UID
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// Service URL
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// GroupsIO group name
	GroupName *string `form:"group_name,omitempty" json:"group_name,omitempty" xml:"group_name,omitempty"`
	// Whether the service is publicly accessible
	Public *bool `form:"public,omitempty" json:"public,omitempty" xml:"public,omitempty"`
	// Manager user IDs who can edit/modify this service
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
	// Auditor user IDs who can audit this service
	Auditors []string `form:"auditors,omitempty" json:"auditors,omitempty" xml:"auditors,omitempty"`
}

// CreateGrpsioMailingListRequestBody is the type of the "mailing-list" service
// "create-grpsio-mailing-list" endpoint HTTP request body.
type CreateGrpsioMailingListRequestBody struct {
	// Mailing list group name
	GroupName *string `form:"group_name,omitempty" json:"group_name,omitempty" xml:"group_name,omitempty"`
	// Whether the mailing list is publicly accessible
	Public *bool `form:"public,omitempty" json:"public,omitempty" xml:"public,omitempty"`
	// Mailing list type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Committee UUID for committee-based mailing lists
	CommitteeUID *string `form:"committee_uid,omitempty" json:"committee_uid,omitempty" xml:"committee_uid,omitempty"`
	// Committee member filters
	CommitteeFilters []string `form:"committee_filters,omitempty" json:"committee_filters,omitempty" xml:"committee_filters,omitempty"`
	// Mailing list description (11-500 characters)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Mailing list title
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Subject tag prefix
	SubjectTag *string `form:"subject_tag,omitempty" json:"subject_tag,omitempty" xml:"subject_tag,omitempty"`
	// Service UUID
	ServiceUID *string `form:"service_uid,omitempty" json:"service_uid,omitempty" xml:"service_uid,omitempty"`
	// Manager user IDs who can edit/modify this service
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
	// Auditor user IDs who can audit this service
	Auditors []string `form:"auditors,omitempty" json:"auditors,omitempty" xml:"auditors,omitempty"`
}

// UpdateGrpsioMailingListRequestBody is the type of the "mailing-list" service
// "update-grpsio-mailing-list" endpoint HTTP request body.
type UpdateGrpsioMailingListRequestBody struct {
	// Mailing list group name
	GroupName *string `form:"group_name,omitempty" json:"group_name,omitempty" xml:"group_name,omitempty"`
	// Whether the mailing list is publicly accessible
	Public *bool `form:"public,omitempty" json:"public,omitempty" xml:"public,omitempty"`
	// Mailing list type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Committee UUID for committee-based mailing lists
	CommitteeUID *string `form:"committee_uid,omitempty" json:"committee_uid,omitempty" xml:"committee_uid,omitempty"`
	// Committee member filters
	CommitteeFilters []string `form:"committee_filters,omitempty" json:"committee_filters,omitempty" xml:"committee_filters,omitempty"`
	// Mailing list description (11-500 characters)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Mailing list title
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Subject tag prefix
	SubjectTag *string `form:"subject_tag,omitempty" json:"subject_tag,omitempty" xml:"subject_tag,omitempty"`
	// Service UUID
	ServiceUID *string `form:"service_uid,omitempty" json:"service_uid,omitempty" xml:"service_uid,omitempty"`
	// Manager user IDs who can edit/modify this service
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
	// Auditor user IDs who can audit this service
	Auditors []string `form:"auditors,omitempty" json:"auditors,omitempty" xml:"auditors,omitempty"`
}

// CreateGrpsioServiceResponseBody is the type of the "mailing-list" service
// "create-grpsio-service" endpoint HTTP response body.
type CreateGrpsioServiceResponseBody struct {
	// Service UID -- unique identifier for the service
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// Service type
	Type string `form:"type" json:"type" xml:"type"`
	// Service domain
	Domain *string `form:"domain,omitempty" json:"domain,omitempty" xml:"domain,omitempty"`
	// GroupsIO group ID
	GroupID *int64 `form:"group_id,omitempty" json:"group_id,omitempty" xml:"group_id,omitempty"`
	// Service status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of global owner email addresses (required for primary, forbidden for
	// shared)
	GlobalOwners []string `form:"global_owners,omitempty" json:"global_owners,omitempty" xml:"global_owners,omitempty"`
	// Email prefix (required for formation and shared, forbidden for primary)
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty" xml:"prefix,omitempty"`
	// Project slug identifier
	ProjectSlug *string `form:"project_slug,omitempty" json:"project_slug,omitempty" xml:"project_slug,omitempty"`
	// LFXv2 Project UID
	ProjectUID string `form:"project_uid" json:"project_uid" xml:"project_uid"`
	// Service URL
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// GroupsIO group name
	GroupName *string `form:"group_name,omitempty" json:"group_name,omitempty" xml:"group_name,omitempty"`
	// Whether the service is publicly accessible
	Public bool `form:"public" json:"public" xml:"public"`
	// Project name (read-only)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty" xml:"project_name,omitempty"`
	// The timestamp when the service was created (read-only)
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The timestamp when the service was last updated (read-only)
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// The timestamp when the service was last reviewed in RFC3339 format
	LastReviewedAt *string `form:"last_reviewed_at,omitempty" json:"last_reviewed_at,omitempty" xml:"last_reviewed_at,omitempty"`
	// The user ID who last reviewed this service
	LastReviewedBy *string `form:"last_reviewed_by,omitempty" json:"last_reviewed_by,omitempty" xml:"last_reviewed_by,omitempty"`
	// The user ID who last audited the service
	LastAuditedBy *string `form:"last_audited_by,omitempty" json:"last_audited_by,omitempty" xml:"last_audited_by,omitempty"`
	// The timestamp when the service was last audited
	LastAuditedTime *string `form:"last_audited_time,omitempty" json:"last_audited_time,omitempty" xml:"last_audited_time,omitempty"`
	// Manager user IDs who can edit/modify this service
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
	// Auditor user IDs who can audit this service
	Auditors []string `form:"auditors,omitempty" json:"auditors,omitempty" xml:"auditors,omitempty"`
}

// GetGrpsioServiceResponseBody is the type of the "mailing-list" service
// "get-grpsio-service" endpoint HTTP response body.
type GetGrpsioServiceResponseBody ServiceWithReadonlyAttributesResponseBody

// UpdateGrpsioServiceResponseBody is the type of the "mailing-list" service
// "update-grpsio-service" endpoint HTTP response body.
type UpdateGrpsioServiceResponseBody struct {
	// Service UID -- unique identifier for the service
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// Service type
	Type string `form:"type" json:"type" xml:"type"`
	// Service domain
	Domain *string `form:"domain,omitempty" json:"domain,omitempty" xml:"domain,omitempty"`
	// GroupsIO group ID
	GroupID *int64 `form:"group_id,omitempty" json:"group_id,omitempty" xml:"group_id,omitempty"`
	// Service status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of global owner email addresses (required for primary, forbidden for
	// shared)
	GlobalOwners []string `form:"global_owners,omitempty" json:"global_owners,omitempty" xml:"global_owners,omitempty"`
	// Email prefix (required for formation and shared, forbidden for primary)
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty" xml:"prefix,omitempty"`
	// Project slug identifier
	ProjectSlug *string `form:"project_slug,omitempty" json:"project_slug,omitempty" xml:"project_slug,omitempty"`
	// LFXv2 Project UID
	ProjectUID string `form:"project_uid" json:"project_uid" xml:"project_uid"`
	// Service URL
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// GroupsIO group name
	GroupName *string `form:"group_name,omitempty" json:"group_name,omitempty" xml:"group_name,omitempty"`
	// Whether the service is publicly accessible
	Public bool `form:"public" json:"public" xml:"public"`
	// Project name (read-only)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty" xml:"project_name,omitempty"`
	// The timestamp when the service was created (read-only)
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The timestamp when the service was last updated (read-only)
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// The timestamp when the service was last reviewed in RFC3339 format
	LastReviewedAt *string `form:"last_reviewed_at,omitempty" json:"last_reviewed_at,omitempty" xml:"last_reviewed_at,omitempty"`
	// The user ID who last reviewed this service
	LastReviewedBy *string `form:"last_reviewed_by,omitempty" json:"last_reviewed_by,omitempty" xml:"last_reviewed_by,omitempty"`
	// The user ID who last audited the service
	LastAuditedBy *string `form:"last_audited_by,omitempty" json:"last_audited_by,omitempty" xml:"last_audited_by,omitempty"`
	// The timestamp when the service was last audited
	LastAuditedTime *string `form:"last_audited_time,omitempty" json:"last_audited_time,omitempty" xml:"last_audited_time,omitempty"`
	// Manager user IDs who can edit/modify this service
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
	// Auditor user IDs who can audit this service
	Auditors []string `form:"auditors,omitempty" json:"auditors,omitempty" xml:"auditors,omitempty"`
}

// CreateGrpsioMailingListResponseBody is the type of the "mailing-list"
// service "create-grpsio-mailing-list" endpoint HTTP response body.
type CreateGrpsioMailingListResponseBody struct {
	// Mailing list UID -- unique identifier for the mailing list
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// Mailing list group name
	GroupName *string `form:"group_name,omitempty" json:"group_name,omitempty" xml:"group_name,omitempty"`
	// Whether the mailing list is publicly accessible
	Public bool `form:"public" json:"public" xml:"public"`
	// Mailing list type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Committee UUID for committee-based mailing lists
	CommitteeUID *string `form:"committee_uid,omitempty" json:"committee_uid,omitempty" xml:"committee_uid,omitempty"`
	// Committee member filters
	CommitteeFilters []string `form:"committee_filters,omitempty" json:"committee_filters,omitempty" xml:"committee_filters,omitempty"`
	// Mailing list description (11-500 characters)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Mailing list title
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Subject tag prefix
	SubjectTag *string `form:"subject_tag,omitempty" json:"subject_tag,omitempty" xml:"subject_tag,omitempty"`
	// Service UUID
	ServiceUID *string `form:"service_uid,omitempty" json:"service_uid,omitempty" xml:"service_uid,omitempty"`
	// LFXv2 Project UID (inherited from parent service)
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// Project name (read-only)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty" xml:"project_name,omitempty"`
	// Project slug identifier (read-only)
	ProjectSlug *string `form:"project_slug,omitempty" json:"project_slug,omitempty" xml:"project_slug,omitempty"`
	// The timestamp when the service was created (read-only)
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The timestamp when the service was last updated (read-only)
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// The timestamp when the service was last reviewed in RFC3339 format
	LastReviewedAt *string `form:"last_reviewed_at,omitempty" json:"last_reviewed_at,omitempty" xml:"last_reviewed_at,omitempty"`
	// The user ID who last reviewed this service
	LastReviewedBy *string `form:"last_reviewed_by,omitempty" json:"last_reviewed_by,omitempty" xml:"last_reviewed_by,omitempty"`
	// Manager user IDs who can edit/modify this service
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
	// Auditor user IDs who can audit this service
	Auditors []string `form:"auditors,omitempty" json:"auditors,omitempty" xml:"auditors,omitempty"`
}

// GetGrpsioMailingListResponseBody is the type of the "mailing-list" service
// "get-grpsio-mailing-list" endpoint HTTP response body.
type GetGrpsioMailingListResponseBody MailingListWithReadonlyAttributesResponseBody

// UpdateGrpsioMailingListResponseBody is the type of the "mailing-list"
// service "update-grpsio-mailing-list" endpoint HTTP response body.
type UpdateGrpsioMailingListResponseBody struct {
	// Mailing list UID -- unique identifier for the mailing list
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// Mailing list group name
	GroupName *string `form:"group_name,omitempty" json:"group_name,omitempty" xml:"group_name,omitempty"`
	// Whether the mailing list is publicly accessible
	Public bool `form:"public" json:"public" xml:"public"`
	// Mailing list type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Committee UUID for committee-based mailing lists
	CommitteeUID *string `form:"committee_uid,omitempty" json:"committee_uid,omitempty" xml:"committee_uid,omitempty"`
	// Committee member filters
	CommitteeFilters []string `form:"committee_filters,omitempty" json:"committee_filters,omitempty" xml:"committee_filters,omitempty"`
	// Mailing list description (11-500 characters)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Mailing list title
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Subject tag prefix
	SubjectTag *string `form:"subject_tag,omitempty" json:"subject_tag,omitempty" xml:"subject_tag,omitempty"`
	// Service UUID
	ServiceUID *string `form:"service_uid,omitempty" json:"service_uid,omitempty" xml:"service_uid,omitempty"`
	// LFXv2 Project UID (inherited from parent service)
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// Project name (read-only)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty" xml:"project_name,omitempty"`
	// Project slug identifier (read-only)
	ProjectSlug *string `form:"project_slug,omitempty" json:"project_slug,omitempty" xml:"project_slug,omitempty"`
	// The timestamp when the service was created (read-only)
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The timestamp when the service was last updated (read-only)
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Manager user IDs who can edit/modify this service
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
	// Auditor user IDs who can audit this service
	Auditors []string `form:"auditors,omitempty" json:"auditors,omitempty" xml:"auditors,omitempty"`
}

// ReadyzServiceUnavailableResponseBody is the type of the "mailing-list"
// service "readyz" endpoint HTTP response body for the "ServiceUnavailable"
// error.
type ReadyzServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateGrpsioServiceBadRequestResponseBody is the type of the "mailing-list"
// service "create-grpsio-service" endpoint HTTP response body for the
// "BadRequest" error.
type CreateGrpsioServiceBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateGrpsioServiceConflictResponseBody is the type of the "mailing-list"
// service "create-grpsio-service" endpoint HTTP response body for the
// "Conflict" error.
type CreateGrpsioServiceConflictResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateGrpsioServiceInternalServerErrorResponseBody is the type of the
// "mailing-list" service "create-grpsio-service" endpoint HTTP response body
// for the "InternalServerError" error.
type CreateGrpsioServiceInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateGrpsioServiceNotFoundResponseBody is the type of the "mailing-list"
// service "create-grpsio-service" endpoint HTTP response body for the
// "NotFound" error.
type CreateGrpsioServiceNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateGrpsioServiceServiceUnavailableResponseBody is the type of the
// "mailing-list" service "create-grpsio-service" endpoint HTTP response body
// for the "ServiceUnavailable" error.
type CreateGrpsioServiceServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetGrpsioServiceBadRequestResponseBody is the type of the "mailing-list"
// service "get-grpsio-service" endpoint HTTP response body for the
// "BadRequest" error.
type GetGrpsioServiceBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetGrpsioServiceInternalServerErrorResponseBody is the type of the
// "mailing-list" service "get-grpsio-service" endpoint HTTP response body for
// the "InternalServerError" error.
type GetGrpsioServiceInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetGrpsioServiceNotFoundResponseBody is the type of the "mailing-list"
// service "get-grpsio-service" endpoint HTTP response body for the "NotFound"
// error.
type GetGrpsioServiceNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetGrpsioServiceServiceUnavailableResponseBody is the type of the
// "mailing-list" service "get-grpsio-service" endpoint HTTP response body for
// the "ServiceUnavailable" error.
type GetGrpsioServiceServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateGrpsioServiceBadRequestResponseBody is the type of the "mailing-list"
// service "update-grpsio-service" endpoint HTTP response body for the
// "BadRequest" error.
type UpdateGrpsioServiceBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateGrpsioServiceConflictResponseBody is the type of the "mailing-list"
// service "update-grpsio-service" endpoint HTTP response body for the
// "Conflict" error.
type UpdateGrpsioServiceConflictResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateGrpsioServiceInternalServerErrorResponseBody is the type of the
// "mailing-list" service "update-grpsio-service" endpoint HTTP response body
// for the "InternalServerError" error.
type UpdateGrpsioServiceInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateGrpsioServiceNotFoundResponseBody is the type of the "mailing-list"
// service "update-grpsio-service" endpoint HTTP response body for the
// "NotFound" error.
type UpdateGrpsioServiceNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateGrpsioServiceServiceUnavailableResponseBody is the type of the
// "mailing-list" service "update-grpsio-service" endpoint HTTP response body
// for the "ServiceUnavailable" error.
type UpdateGrpsioServiceServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteGrpsioServiceBadRequestResponseBody is the type of the "mailing-list"
// service "delete-grpsio-service" endpoint HTTP response body for the
// "BadRequest" error.
type DeleteGrpsioServiceBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteGrpsioServiceConflictResponseBody is the type of the "mailing-list"
// service "delete-grpsio-service" endpoint HTTP response body for the
// "Conflict" error.
type DeleteGrpsioServiceConflictResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteGrpsioServiceInternalServerErrorResponseBody is the type of the
// "mailing-list" service "delete-grpsio-service" endpoint HTTP response body
// for the "InternalServerError" error.
type DeleteGrpsioServiceInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteGrpsioServiceNotFoundResponseBody is the type of the "mailing-list"
// service "delete-grpsio-service" endpoint HTTP response body for the
// "NotFound" error.
type DeleteGrpsioServiceNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteGrpsioServiceServiceUnavailableResponseBody is the type of the
// "mailing-list" service "delete-grpsio-service" endpoint HTTP response body
// for the "ServiceUnavailable" error.
type DeleteGrpsioServiceServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateGrpsioMailingListBadRequestResponseBody is the type of the
// "mailing-list" service "create-grpsio-mailing-list" endpoint HTTP response
// body for the "BadRequest" error.
type CreateGrpsioMailingListBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateGrpsioMailingListConflictResponseBody is the type of the
// "mailing-list" service "create-grpsio-mailing-list" endpoint HTTP response
// body for the "Conflict" error.
type CreateGrpsioMailingListConflictResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateGrpsioMailingListInternalServerErrorResponseBody is the type of the
// "mailing-list" service "create-grpsio-mailing-list" endpoint HTTP response
// body for the "InternalServerError" error.
type CreateGrpsioMailingListInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateGrpsioMailingListNotFoundResponseBody is the type of the
// "mailing-list" service "create-grpsio-mailing-list" endpoint HTTP response
// body for the "NotFound" error.
type CreateGrpsioMailingListNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateGrpsioMailingListServiceUnavailableResponseBody is the type of the
// "mailing-list" service "create-grpsio-mailing-list" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type CreateGrpsioMailingListServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetGrpsioMailingListBadRequestResponseBody is the type of the "mailing-list"
// service "get-grpsio-mailing-list" endpoint HTTP response body for the
// "BadRequest" error.
type GetGrpsioMailingListBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetGrpsioMailingListInternalServerErrorResponseBody is the type of the
// "mailing-list" service "get-grpsio-mailing-list" endpoint HTTP response body
// for the "InternalServerError" error.
type GetGrpsioMailingListInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetGrpsioMailingListNotFoundResponseBody is the type of the "mailing-list"
// service "get-grpsio-mailing-list" endpoint HTTP response body for the
// "NotFound" error.
type GetGrpsioMailingListNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetGrpsioMailingListServiceUnavailableResponseBody is the type of the
// "mailing-list" service "get-grpsio-mailing-list" endpoint HTTP response body
// for the "ServiceUnavailable" error.
type GetGrpsioMailingListServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateGrpsioMailingListBadRequestResponseBody is the type of the
// "mailing-list" service "update-grpsio-mailing-list" endpoint HTTP response
// body for the "BadRequest" error.
type UpdateGrpsioMailingListBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateGrpsioMailingListConflictResponseBody is the type of the
// "mailing-list" service "update-grpsio-mailing-list" endpoint HTTP response
// body for the "Conflict" error.
type UpdateGrpsioMailingListConflictResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateGrpsioMailingListInternalServerErrorResponseBody is the type of the
// "mailing-list" service "update-grpsio-mailing-list" endpoint HTTP response
// body for the "InternalServerError" error.
type UpdateGrpsioMailingListInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateGrpsioMailingListNotFoundResponseBody is the type of the
// "mailing-list" service "update-grpsio-mailing-list" endpoint HTTP response
// body for the "NotFound" error.
type UpdateGrpsioMailingListNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateGrpsioMailingListServiceUnavailableResponseBody is the type of the
// "mailing-list" service "update-grpsio-mailing-list" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type UpdateGrpsioMailingListServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteGrpsioMailingListBadRequestResponseBody is the type of the
// "mailing-list" service "delete-grpsio-mailing-list" endpoint HTTP response
// body for the "BadRequest" error.
type DeleteGrpsioMailingListBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteGrpsioMailingListConflictResponseBody is the type of the
// "mailing-list" service "delete-grpsio-mailing-list" endpoint HTTP response
// body for the "Conflict" error.
type DeleteGrpsioMailingListConflictResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteGrpsioMailingListInternalServerErrorResponseBody is the type of the
// "mailing-list" service "delete-grpsio-mailing-list" endpoint HTTP response
// body for the "InternalServerError" error.
type DeleteGrpsioMailingListInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteGrpsioMailingListNotFoundResponseBody is the type of the
// "mailing-list" service "delete-grpsio-mailing-list" endpoint HTTP response
// body for the "NotFound" error.
type DeleteGrpsioMailingListNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteGrpsioMailingListServiceUnavailableResponseBody is the type of the
// "mailing-list" service "delete-grpsio-mailing-list" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type DeleteGrpsioMailingListServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// ServiceWithReadonlyAttributesResponseBody is used to define fields on
// response body types.
type ServiceWithReadonlyAttributesResponseBody struct {
	// Service UID -- unique identifier for the service
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// Service type
	Type string `form:"type" json:"type" xml:"type"`
	// Service domain
	Domain *string `form:"domain,omitempty" json:"domain,omitempty" xml:"domain,omitempty"`
	// GroupsIO group ID
	GroupID *int64 `form:"group_id,omitempty" json:"group_id,omitempty" xml:"group_id,omitempty"`
	// Service status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of global owner email addresses (required for primary, forbidden for
	// shared)
	GlobalOwners []string `form:"global_owners,omitempty" json:"global_owners,omitempty" xml:"global_owners,omitempty"`
	// Email prefix (required for formation and shared, forbidden for primary)
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty" xml:"prefix,omitempty"`
	// Project slug identifier
	ProjectSlug *string `form:"project_slug,omitempty" json:"project_slug,omitempty" xml:"project_slug,omitempty"`
	// LFXv2 Project UID
	ProjectUID string `form:"project_uid" json:"project_uid" xml:"project_uid"`
	// Service URL
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// GroupsIO group name
	GroupName *string `form:"group_name,omitempty" json:"group_name,omitempty" xml:"group_name,omitempty"`
	// Whether the service is publicly accessible
	Public bool `form:"public" json:"public" xml:"public"`
	// Project name (read-only)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty" xml:"project_name,omitempty"`
	// The timestamp when the service was created (read-only)
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The timestamp when the service was last updated (read-only)
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// The timestamp when the service was last reviewed in RFC3339 format
	LastReviewedAt *string `form:"last_reviewed_at,omitempty" json:"last_reviewed_at,omitempty" xml:"last_reviewed_at,omitempty"`
	// The user ID who last reviewed this service
	LastReviewedBy *string `form:"last_reviewed_by,omitempty" json:"last_reviewed_by,omitempty" xml:"last_reviewed_by,omitempty"`
	// The user ID who last audited the service
	LastAuditedBy *string `form:"last_audited_by,omitempty" json:"last_audited_by,omitempty" xml:"last_audited_by,omitempty"`
	// The timestamp when the service was last audited
	LastAuditedTime *string `form:"last_audited_time,omitempty" json:"last_audited_time,omitempty" xml:"last_audited_time,omitempty"`
	// Manager user IDs who can edit/modify this service
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
	// Auditor user IDs who can audit this service
	Auditors []string `form:"auditors,omitempty" json:"auditors,omitempty" xml:"auditors,omitempty"`
}

// MailingListWithReadonlyAttributesResponseBody is used to define fields on
// response body types.
type MailingListWithReadonlyAttributesResponseBody struct {
	// Mailing list UID -- unique identifier for the mailing list
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// Mailing list group name
	GroupName *string `form:"group_name,omitempty" json:"group_name,omitempty" xml:"group_name,omitempty"`
	// Whether the mailing list is publicly accessible
	Public bool `form:"public" json:"public" xml:"public"`
	// Mailing list type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Committee UUID for committee-based mailing lists
	CommitteeUID *string `form:"committee_uid,omitempty" json:"committee_uid,omitempty" xml:"committee_uid,omitempty"`
	// Committee member filters
	CommitteeFilters []string `form:"committee_filters,omitempty" json:"committee_filters,omitempty" xml:"committee_filters,omitempty"`
	// Mailing list description (11-500 characters)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Mailing list title
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Subject tag prefix
	SubjectTag *string `form:"subject_tag,omitempty" json:"subject_tag,omitempty" xml:"subject_tag,omitempty"`
	// Service UUID
	ServiceUID *string `form:"service_uid,omitempty" json:"service_uid,omitempty" xml:"service_uid,omitempty"`
	// LFXv2 Project UID (inherited from parent service)
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// Project name (read-only)
	ProjectName *string `form:"project_name,omitempty" json:"project_name,omitempty" xml:"project_name,omitempty"`
	// Project slug identifier (read-only)
	ProjectSlug *string `form:"project_slug,omitempty" json:"project_slug,omitempty" xml:"project_slug,omitempty"`
	// The timestamp when the service was created (read-only)
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The timestamp when the service was last updated (read-only)
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Manager user IDs who can edit/modify this service
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
	// Auditor user IDs who can audit this service
	Auditors []string `form:"auditors,omitempty" json:"auditors,omitempty" xml:"auditors,omitempty"`
}

// NewCreateGrpsioServiceResponseBody builds the HTTP response body from the
// result of the "create-grpsio-service" endpoint of the "mailing-list" service.
func NewCreateGrpsioServiceResponseBody(res *mailinglist.ServiceFull) *CreateGrpsioServiceResponseBody {
	body := &CreateGrpsioServiceResponseBody{
		UID:             res.UID,
		Type:            res.Type,
		Domain:          res.Domain,
		GroupID:         res.GroupID,
		Status:          res.Status,
		Prefix:          res.Prefix,
		ProjectSlug:     res.ProjectSlug,
		ProjectUID:      res.ProjectUID,
		URL:             res.URL,
		GroupName:       res.GroupName,
		Public:          res.Public,
		ProjectName:     res.ProjectName,
		CreatedAt:       res.CreatedAt,
		UpdatedAt:       res.UpdatedAt,
		LastReviewedAt:  res.LastReviewedAt,
		LastReviewedBy:  res.LastReviewedBy,
		LastAuditedBy:   res.LastAuditedBy,
		LastAuditedTime: res.LastAuditedTime,
	}
	if res.GlobalOwners != nil {
		body.GlobalOwners = make([]string, len(res.GlobalOwners))
		for i, val := range res.GlobalOwners {
			body.GlobalOwners[i] = val
		}
	}
	{
		var zero bool
		if body.Public == zero {
			body.Public = false
		}
	}
	if res.Writers != nil {
		body.Writers = make([]string, len(res.Writers))
		for i, val := range res.Writers {
			body.Writers[i] = val
		}
	}
	if res.Auditors != nil {
		body.Auditors = make([]string, len(res.Auditors))
		for i, val := range res.Auditors {
			body.Auditors[i] = val
		}
	}
	return body
}

// NewGetGrpsioServiceResponseBody builds the HTTP response body from the
// result of the "get-grpsio-service" endpoint of the "mailing-list" service.
func NewGetGrpsioServiceResponseBody(res *mailinglist.GetGrpsioServiceResult) *GetGrpsioServiceResponseBody {
	body := &GetGrpsioServiceResponseBody{
		UID:             res.Service.UID,
		Type:            res.Service.Type,
		Domain:          res.Service.Domain,
		GroupID:         res.Service.GroupID,
		Status:          res.Service.Status,
		Prefix:          res.Service.Prefix,
		ProjectSlug:     res.Service.ProjectSlug,
		ProjectUID:      res.Service.ProjectUID,
		URL:             res.Service.URL,
		GroupName:       res.Service.GroupName,
		Public:          res.Service.Public,
		ProjectName:     res.Service.ProjectName,
		CreatedAt:       res.Service.CreatedAt,
		UpdatedAt:       res.Service.UpdatedAt,
		LastReviewedAt:  res.Service.LastReviewedAt,
		LastReviewedBy:  res.Service.LastReviewedBy,
		LastAuditedBy:   res.Service.LastAuditedBy,
		LastAuditedTime: res.Service.LastAuditedTime,
	}
	if res.Service.GlobalOwners != nil {
		body.GlobalOwners = make([]string, len(res.Service.GlobalOwners))
		for i, val := range res.Service.GlobalOwners {
			body.GlobalOwners[i] = val
		}
	}
	{
		var zero bool
		if body.Public == zero {
			body.Public = false
		}
	}
	if res.Service.Writers != nil {
		body.Writers = make([]string, len(res.Service.Writers))
		for i, val := range res.Service.Writers {
			body.Writers[i] = val
		}
	}
	if res.Service.Auditors != nil {
		body.Auditors = make([]string, len(res.Service.Auditors))
		for i, val := range res.Service.Auditors {
			body.Auditors[i] = val
		}
	}
	return body
}

// NewUpdateGrpsioServiceResponseBody builds the HTTP response body from the
// result of the "update-grpsio-service" endpoint of the "mailing-list" service.
func NewUpdateGrpsioServiceResponseBody(res *mailinglist.ServiceWithReadonlyAttributes) *UpdateGrpsioServiceResponseBody {
	body := &UpdateGrpsioServiceResponseBody{
		UID:             res.UID,
		Type:            res.Type,
		Domain:          res.Domain,
		GroupID:         res.GroupID,
		Status:          res.Status,
		Prefix:          res.Prefix,
		ProjectSlug:     res.ProjectSlug,
		ProjectUID:      res.ProjectUID,
		URL:             res.URL,
		GroupName:       res.GroupName,
		Public:          res.Public,
		ProjectName:     res.ProjectName,
		CreatedAt:       res.CreatedAt,
		UpdatedAt:       res.UpdatedAt,
		LastReviewedAt:  res.LastReviewedAt,
		LastReviewedBy:  res.LastReviewedBy,
		LastAuditedBy:   res.LastAuditedBy,
		LastAuditedTime: res.LastAuditedTime,
	}
	if res.GlobalOwners != nil {
		body.GlobalOwners = make([]string, len(res.GlobalOwners))
		for i, val := range res.GlobalOwners {
			body.GlobalOwners[i] = val
		}
	}
	{
		var zero bool
		if body.Public == zero {
			body.Public = false
		}
	}
	if res.Writers != nil {
		body.Writers = make([]string, len(res.Writers))
		for i, val := range res.Writers {
			body.Writers[i] = val
		}
	}
	if res.Auditors != nil {
		body.Auditors = make([]string, len(res.Auditors))
		for i, val := range res.Auditors {
			body.Auditors[i] = val
		}
	}
	return body
}

// NewCreateGrpsioMailingListResponseBody builds the HTTP response body from
// the result of the "create-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewCreateGrpsioMailingListResponseBody(res *mailinglist.MailingListFull) *CreateGrpsioMailingListResponseBody {
	body := &CreateGrpsioMailingListResponseBody{
		UID:            res.UID,
		GroupName:      res.GroupName,
		Public:         res.Public,
		Type:           res.Type,
		CommitteeUID:   res.CommitteeUID,
		Description:    res.Description,
		Title:          res.Title,
		SubjectTag:     res.SubjectTag,
		ServiceUID:     res.ServiceUID,
		ProjectUID:     res.ProjectUID,
		ProjectName:    res.ProjectName,
		ProjectSlug:    res.ProjectSlug,
		CreatedAt:      res.CreatedAt,
		UpdatedAt:      res.UpdatedAt,
		LastReviewedAt: res.LastReviewedAt,
		LastReviewedBy: res.LastReviewedBy,
	}
	{
		var zero bool
		if body.Public == zero {
			body.Public = false
		}
	}
	if res.CommitteeFilters != nil {
		body.CommitteeFilters = make([]string, len(res.CommitteeFilters))
		for i, val := range res.CommitteeFilters {
			body.CommitteeFilters[i] = val
		}
	}
	if res.Writers != nil {
		body.Writers = make([]string, len(res.Writers))
		for i, val := range res.Writers {
			body.Writers[i] = val
		}
	}
	if res.Auditors != nil {
		body.Auditors = make([]string, len(res.Auditors))
		for i, val := range res.Auditors {
			body.Auditors[i] = val
		}
	}
	return body
}

// NewGetGrpsioMailingListResponseBody builds the HTTP response body from the
// result of the "get-grpsio-mailing-list" endpoint of the "mailing-list"
// service.
func NewGetGrpsioMailingListResponseBody(res *mailinglist.GetGrpsioMailingListResult) *GetGrpsioMailingListResponseBody {
	body := &GetGrpsioMailingListResponseBody{
		UID:          res.MailingList.UID,
		GroupName:    res.MailingList.GroupName,
		Public:       res.MailingList.Public,
		Type:         res.MailingList.Type,
		CommitteeUID: res.MailingList.CommitteeUID,
		Description:  res.MailingList.Description,
		Title:        res.MailingList.Title,
		SubjectTag:   res.MailingList.SubjectTag,
		ServiceUID:   res.MailingList.ServiceUID,
		ProjectUID:   res.MailingList.ProjectUID,
		ProjectName:  res.MailingList.ProjectName,
		ProjectSlug:  res.MailingList.ProjectSlug,
		CreatedAt:    res.MailingList.CreatedAt,
		UpdatedAt:    res.MailingList.UpdatedAt,
	}
	{
		var zero bool
		if body.Public == zero {
			body.Public = false
		}
	}
	if res.MailingList.CommitteeFilters != nil {
		body.CommitteeFilters = make([]string, len(res.MailingList.CommitteeFilters))
		for i, val := range res.MailingList.CommitteeFilters {
			body.CommitteeFilters[i] = val
		}
	}
	if res.MailingList.Writers != nil {
		body.Writers = make([]string, len(res.MailingList.Writers))
		for i, val := range res.MailingList.Writers {
			body.Writers[i] = val
		}
	}
	if res.MailingList.Auditors != nil {
		body.Auditors = make([]string, len(res.MailingList.Auditors))
		for i, val := range res.MailingList.Auditors {
			body.Auditors[i] = val
		}
	}
	return body
}

// NewUpdateGrpsioMailingListResponseBody builds the HTTP response body from
// the result of the "update-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewUpdateGrpsioMailingListResponseBody(res *mailinglist.MailingListWithReadonlyAttributes) *UpdateGrpsioMailingListResponseBody {
	body := &UpdateGrpsioMailingListResponseBody{
		UID:          res.UID,
		GroupName:    res.GroupName,
		Public:       res.Public,
		Type:         res.Type,
		CommitteeUID: res.CommitteeUID,
		Description:  res.Description,
		Title:        res.Title,
		SubjectTag:   res.SubjectTag,
		ServiceUID:   res.ServiceUID,
		ProjectUID:   res.ProjectUID,
		ProjectName:  res.ProjectName,
		ProjectSlug:  res.ProjectSlug,
		CreatedAt:    res.CreatedAt,
		UpdatedAt:    res.UpdatedAt,
	}
	{
		var zero bool
		if body.Public == zero {
			body.Public = false
		}
	}
	if res.CommitteeFilters != nil {
		body.CommitteeFilters = make([]string, len(res.CommitteeFilters))
		for i, val := range res.CommitteeFilters {
			body.CommitteeFilters[i] = val
		}
	}
	if res.Writers != nil {
		body.Writers = make([]string, len(res.Writers))
		for i, val := range res.Writers {
			body.Writers[i] = val
		}
	}
	if res.Auditors != nil {
		body.Auditors = make([]string, len(res.Auditors))
		for i, val := range res.Auditors {
			body.Auditors[i] = val
		}
	}
	return body
}

// NewReadyzServiceUnavailableResponseBody builds the HTTP response body from
// the result of the "readyz" endpoint of the "mailing-list" service.
func NewReadyzServiceUnavailableResponseBody(res *mailinglist.ServiceUnavailableError) *ReadyzServiceUnavailableResponseBody {
	body := &ReadyzServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioServiceBadRequestResponseBody builds the HTTP response body
// from the result of the "create-grpsio-service" endpoint of the
// "mailing-list" service.
func NewCreateGrpsioServiceBadRequestResponseBody(res *mailinglist.BadRequestError) *CreateGrpsioServiceBadRequestResponseBody {
	body := &CreateGrpsioServiceBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioServiceConflictResponseBody builds the HTTP response body
// from the result of the "create-grpsio-service" endpoint of the
// "mailing-list" service.
func NewCreateGrpsioServiceConflictResponseBody(res *mailinglist.ConflictError) *CreateGrpsioServiceConflictResponseBody {
	body := &CreateGrpsioServiceConflictResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioServiceInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "create-grpsio-service" endpoint of the
// "mailing-list" service.
func NewCreateGrpsioServiceInternalServerErrorResponseBody(res *mailinglist.InternalServerError) *CreateGrpsioServiceInternalServerErrorResponseBody {
	body := &CreateGrpsioServiceInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioServiceNotFoundResponseBody builds the HTTP response body
// from the result of the "create-grpsio-service" endpoint of the
// "mailing-list" service.
func NewCreateGrpsioServiceNotFoundResponseBody(res *mailinglist.NotFoundError) *CreateGrpsioServiceNotFoundResponseBody {
	body := &CreateGrpsioServiceNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioServiceServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "create-grpsio-service" endpoint of the
// "mailing-list" service.
func NewCreateGrpsioServiceServiceUnavailableResponseBody(res *mailinglist.ServiceUnavailableError) *CreateGrpsioServiceServiceUnavailableResponseBody {
	body := &CreateGrpsioServiceServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetGrpsioServiceBadRequestResponseBody builds the HTTP response body from
// the result of the "get-grpsio-service" endpoint of the "mailing-list"
// service.
func NewGetGrpsioServiceBadRequestResponseBody(res *mailinglist.BadRequestError) *GetGrpsioServiceBadRequestResponseBody {
	body := &GetGrpsioServiceBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetGrpsioServiceInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "get-grpsio-service" endpoint of the
// "mailing-list" service.
func NewGetGrpsioServiceInternalServerErrorResponseBody(res *mailinglist.InternalServerError) *GetGrpsioServiceInternalServerErrorResponseBody {
	body := &GetGrpsioServiceInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetGrpsioServiceNotFoundResponseBody builds the HTTP response body from
// the result of the "get-grpsio-service" endpoint of the "mailing-list"
// service.
func NewGetGrpsioServiceNotFoundResponseBody(res *mailinglist.NotFoundError) *GetGrpsioServiceNotFoundResponseBody {
	body := &GetGrpsioServiceNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetGrpsioServiceServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "get-grpsio-service" endpoint of the
// "mailing-list" service.
func NewGetGrpsioServiceServiceUnavailableResponseBody(res *mailinglist.ServiceUnavailableError) *GetGrpsioServiceServiceUnavailableResponseBody {
	body := &GetGrpsioServiceServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateGrpsioServiceBadRequestResponseBody builds the HTTP response body
// from the result of the "update-grpsio-service" endpoint of the
// "mailing-list" service.
func NewUpdateGrpsioServiceBadRequestResponseBody(res *mailinglist.BadRequestError) *UpdateGrpsioServiceBadRequestResponseBody {
	body := &UpdateGrpsioServiceBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateGrpsioServiceConflictResponseBody builds the HTTP response body
// from the result of the "update-grpsio-service" endpoint of the
// "mailing-list" service.
func NewUpdateGrpsioServiceConflictResponseBody(res *mailinglist.ConflictError) *UpdateGrpsioServiceConflictResponseBody {
	body := &UpdateGrpsioServiceConflictResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateGrpsioServiceInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "update-grpsio-service" endpoint of the
// "mailing-list" service.
func NewUpdateGrpsioServiceInternalServerErrorResponseBody(res *mailinglist.InternalServerError) *UpdateGrpsioServiceInternalServerErrorResponseBody {
	body := &UpdateGrpsioServiceInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateGrpsioServiceNotFoundResponseBody builds the HTTP response body
// from the result of the "update-grpsio-service" endpoint of the
// "mailing-list" service.
func NewUpdateGrpsioServiceNotFoundResponseBody(res *mailinglist.NotFoundError) *UpdateGrpsioServiceNotFoundResponseBody {
	body := &UpdateGrpsioServiceNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateGrpsioServiceServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "update-grpsio-service" endpoint of the
// "mailing-list" service.
func NewUpdateGrpsioServiceServiceUnavailableResponseBody(res *mailinglist.ServiceUnavailableError) *UpdateGrpsioServiceServiceUnavailableResponseBody {
	body := &UpdateGrpsioServiceServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteGrpsioServiceBadRequestResponseBody builds the HTTP response body
// from the result of the "delete-grpsio-service" endpoint of the
// "mailing-list" service.
func NewDeleteGrpsioServiceBadRequestResponseBody(res *mailinglist.BadRequestError) *DeleteGrpsioServiceBadRequestResponseBody {
	body := &DeleteGrpsioServiceBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteGrpsioServiceConflictResponseBody builds the HTTP response body
// from the result of the "delete-grpsio-service" endpoint of the
// "mailing-list" service.
func NewDeleteGrpsioServiceConflictResponseBody(res *mailinglist.ConflictError) *DeleteGrpsioServiceConflictResponseBody {
	body := &DeleteGrpsioServiceConflictResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteGrpsioServiceInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "delete-grpsio-service" endpoint of the
// "mailing-list" service.
func NewDeleteGrpsioServiceInternalServerErrorResponseBody(res *mailinglist.InternalServerError) *DeleteGrpsioServiceInternalServerErrorResponseBody {
	body := &DeleteGrpsioServiceInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteGrpsioServiceNotFoundResponseBody builds the HTTP response body
// from the result of the "delete-grpsio-service" endpoint of the
// "mailing-list" service.
func NewDeleteGrpsioServiceNotFoundResponseBody(res *mailinglist.NotFoundError) *DeleteGrpsioServiceNotFoundResponseBody {
	body := &DeleteGrpsioServiceNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteGrpsioServiceServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "delete-grpsio-service" endpoint of the
// "mailing-list" service.
func NewDeleteGrpsioServiceServiceUnavailableResponseBody(res *mailinglist.ServiceUnavailableError) *DeleteGrpsioServiceServiceUnavailableResponseBody {
	body := &DeleteGrpsioServiceServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioMailingListBadRequestResponseBody builds the HTTP response
// body from the result of the "create-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewCreateGrpsioMailingListBadRequestResponseBody(res *mailinglist.BadRequestError) *CreateGrpsioMailingListBadRequestResponseBody {
	body := &CreateGrpsioMailingListBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioMailingListConflictResponseBody builds the HTTP response body
// from the result of the "create-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewCreateGrpsioMailingListConflictResponseBody(res *mailinglist.ConflictError) *CreateGrpsioMailingListConflictResponseBody {
	body := &CreateGrpsioMailingListConflictResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioMailingListInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "create-grpsio-mailing-list" endpoint
// of the "mailing-list" service.
func NewCreateGrpsioMailingListInternalServerErrorResponseBody(res *mailinglist.InternalServerError) *CreateGrpsioMailingListInternalServerErrorResponseBody {
	body := &CreateGrpsioMailingListInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioMailingListNotFoundResponseBody builds the HTTP response body
// from the result of the "create-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewCreateGrpsioMailingListNotFoundResponseBody(res *mailinglist.NotFoundError) *CreateGrpsioMailingListNotFoundResponseBody {
	body := &CreateGrpsioMailingListNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioMailingListServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "create-grpsio-mailing-list" endpoint
// of the "mailing-list" service.
func NewCreateGrpsioMailingListServiceUnavailableResponseBody(res *mailinglist.ServiceUnavailableError) *CreateGrpsioMailingListServiceUnavailableResponseBody {
	body := &CreateGrpsioMailingListServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetGrpsioMailingListBadRequestResponseBody builds the HTTP response body
// from the result of the "get-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewGetGrpsioMailingListBadRequestResponseBody(res *mailinglist.BadRequestError) *GetGrpsioMailingListBadRequestResponseBody {
	body := &GetGrpsioMailingListBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetGrpsioMailingListInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "get-grpsio-mailing-list" endpoint of
// the "mailing-list" service.
func NewGetGrpsioMailingListInternalServerErrorResponseBody(res *mailinglist.InternalServerError) *GetGrpsioMailingListInternalServerErrorResponseBody {
	body := &GetGrpsioMailingListInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetGrpsioMailingListNotFoundResponseBody builds the HTTP response body
// from the result of the "get-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewGetGrpsioMailingListNotFoundResponseBody(res *mailinglist.NotFoundError) *GetGrpsioMailingListNotFoundResponseBody {
	body := &GetGrpsioMailingListNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetGrpsioMailingListServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "get-grpsio-mailing-list" endpoint of
// the "mailing-list" service.
func NewGetGrpsioMailingListServiceUnavailableResponseBody(res *mailinglist.ServiceUnavailableError) *GetGrpsioMailingListServiceUnavailableResponseBody {
	body := &GetGrpsioMailingListServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateGrpsioMailingListBadRequestResponseBody builds the HTTP response
// body from the result of the "update-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewUpdateGrpsioMailingListBadRequestResponseBody(res *mailinglist.BadRequestError) *UpdateGrpsioMailingListBadRequestResponseBody {
	body := &UpdateGrpsioMailingListBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateGrpsioMailingListConflictResponseBody builds the HTTP response body
// from the result of the "update-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewUpdateGrpsioMailingListConflictResponseBody(res *mailinglist.ConflictError) *UpdateGrpsioMailingListConflictResponseBody {
	body := &UpdateGrpsioMailingListConflictResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateGrpsioMailingListInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "update-grpsio-mailing-list" endpoint
// of the "mailing-list" service.
func NewUpdateGrpsioMailingListInternalServerErrorResponseBody(res *mailinglist.InternalServerError) *UpdateGrpsioMailingListInternalServerErrorResponseBody {
	body := &UpdateGrpsioMailingListInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateGrpsioMailingListNotFoundResponseBody builds the HTTP response body
// from the result of the "update-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewUpdateGrpsioMailingListNotFoundResponseBody(res *mailinglist.NotFoundError) *UpdateGrpsioMailingListNotFoundResponseBody {
	body := &UpdateGrpsioMailingListNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateGrpsioMailingListServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "update-grpsio-mailing-list" endpoint
// of the "mailing-list" service.
func NewUpdateGrpsioMailingListServiceUnavailableResponseBody(res *mailinglist.ServiceUnavailableError) *UpdateGrpsioMailingListServiceUnavailableResponseBody {
	body := &UpdateGrpsioMailingListServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteGrpsioMailingListBadRequestResponseBody builds the HTTP response
// body from the result of the "delete-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewDeleteGrpsioMailingListBadRequestResponseBody(res *mailinglist.BadRequestError) *DeleteGrpsioMailingListBadRequestResponseBody {
	body := &DeleteGrpsioMailingListBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteGrpsioMailingListConflictResponseBody builds the HTTP response body
// from the result of the "delete-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewDeleteGrpsioMailingListConflictResponseBody(res *mailinglist.ConflictError) *DeleteGrpsioMailingListConflictResponseBody {
	body := &DeleteGrpsioMailingListConflictResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteGrpsioMailingListInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "delete-grpsio-mailing-list" endpoint
// of the "mailing-list" service.
func NewDeleteGrpsioMailingListInternalServerErrorResponseBody(res *mailinglist.InternalServerError) *DeleteGrpsioMailingListInternalServerErrorResponseBody {
	body := &DeleteGrpsioMailingListInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteGrpsioMailingListNotFoundResponseBody builds the HTTP response body
// from the result of the "delete-grpsio-mailing-list" endpoint of the
// "mailing-list" service.
func NewDeleteGrpsioMailingListNotFoundResponseBody(res *mailinglist.NotFoundError) *DeleteGrpsioMailingListNotFoundResponseBody {
	body := &DeleteGrpsioMailingListNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteGrpsioMailingListServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "delete-grpsio-mailing-list" endpoint
// of the "mailing-list" service.
func NewDeleteGrpsioMailingListServiceUnavailableResponseBody(res *mailinglist.ServiceUnavailableError) *DeleteGrpsioMailingListServiceUnavailableResponseBody {
	body := &DeleteGrpsioMailingListServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateGrpsioServicePayload builds a mailing-list service
// create-grpsio-service endpoint payload.
func NewCreateGrpsioServicePayload(body *CreateGrpsioServiceRequestBody, version *string, bearerToken *string) *mailinglist.CreateGrpsioServicePayload {
	v := &mailinglist.CreateGrpsioServicePayload{
		Type:        *body.Type,
		Domain:      body.Domain,
		GroupID:     body.GroupID,
		Status:      body.Status,
		Prefix:      body.Prefix,
		ProjectSlug: body.ProjectSlug,
		ProjectUID:  *body.ProjectUID,
		URL:         body.URL,
		GroupName:   body.GroupName,
	}
	if body.Public != nil {
		v.Public = *body.Public
	}
	if body.GlobalOwners != nil {
		v.GlobalOwners = make([]string, len(body.GlobalOwners))
		for i, val := range body.GlobalOwners {
			v.GlobalOwners[i] = val
		}
	}
	if body.Public == nil {
		v.Public = false
	}
	if body.Writers != nil {
		v.Writers = make([]string, len(body.Writers))
		for i, val := range body.Writers {
			v.Writers[i] = val
		}
	}
	if body.Auditors != nil {
		v.Auditors = make([]string, len(body.Auditors))
		for i, val := range body.Auditors {
			v.Auditors[i] = val
		}
	}
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewGetGrpsioServicePayload builds a mailing-list service get-grpsio-service
// endpoint payload.
func NewGetGrpsioServicePayload(uid string, version *string, bearerToken *string) *mailinglist.GetGrpsioServicePayload {
	v := &mailinglist.GetGrpsioServicePayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewUpdateGrpsioServicePayload builds a mailing-list service
// update-grpsio-service endpoint payload.
func NewUpdateGrpsioServicePayload(body *UpdateGrpsioServiceRequestBody, uid string, version *string, bearerToken *string, ifMatch *string) *mailinglist.UpdateGrpsioServicePayload {
	v := &mailinglist.UpdateGrpsioServicePayload{
		Type:        *body.Type,
		Domain:      body.Domain,
		GroupID:     body.GroupID,
		Status:      body.Status,
		Prefix:      body.Prefix,
		ProjectSlug: body.ProjectSlug,
		ProjectUID:  *body.ProjectUID,
		URL:         body.URL,
		GroupName:   body.GroupName,
	}
	if body.Public != nil {
		v.Public = *body.Public
	}
	if body.GlobalOwners != nil {
		v.GlobalOwners = make([]string, len(body.GlobalOwners))
		for i, val := range body.GlobalOwners {
			v.GlobalOwners[i] = val
		}
	}
	if body.Public == nil {
		v.Public = false
	}
	if body.Writers != nil {
		v.Writers = make([]string, len(body.Writers))
		for i, val := range body.Writers {
			v.Writers[i] = val
		}
	}
	if body.Auditors != nil {
		v.Auditors = make([]string, len(body.Auditors))
		for i, val := range body.Auditors {
			v.Auditors[i] = val
		}
	}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// NewDeleteGrpsioServicePayload builds a mailing-list service
// delete-grpsio-service endpoint payload.
func NewDeleteGrpsioServicePayload(uid string, version *string, bearerToken *string, ifMatch *string) *mailinglist.DeleteGrpsioServicePayload {
	v := &mailinglist.DeleteGrpsioServicePayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// NewCreateGrpsioMailingListPayload builds a mailing-list service
// create-grpsio-mailing-list endpoint payload.
func NewCreateGrpsioMailingListPayload(body *CreateGrpsioMailingListRequestBody, version *string, bearerToken *string) *mailinglist.CreateGrpsioMailingListPayload {
	v := &mailinglist.CreateGrpsioMailingListPayload{
		GroupName:    *body.GroupName,
		Public:       *body.Public,
		Type:         *body.Type,
		CommitteeUID: body.CommitteeUID,
		Description:  *body.Description,
		Title:        *body.Title,
		SubjectTag:   body.SubjectTag,
		ServiceUID:   *body.ServiceUID,
	}
	if body.CommitteeFilters != nil {
		v.CommitteeFilters = make([]string, len(body.CommitteeFilters))
		for i, val := range body.CommitteeFilters {
			v.CommitteeFilters[i] = val
		}
	}
	if body.Writers != nil {
		v.Writers = make([]string, len(body.Writers))
		for i, val := range body.Writers {
			v.Writers[i] = val
		}
	}
	if body.Auditors != nil {
		v.Auditors = make([]string, len(body.Auditors))
		for i, val := range body.Auditors {
			v.Auditors[i] = val
		}
	}
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewGetGrpsioMailingListPayload builds a mailing-list service
// get-grpsio-mailing-list endpoint payload.
func NewGetGrpsioMailingListPayload(uid string, version *string, bearerToken *string) *mailinglist.GetGrpsioMailingListPayload {
	v := &mailinglist.GetGrpsioMailingListPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewUpdateGrpsioMailingListPayload builds a mailing-list service
// update-grpsio-mailing-list endpoint payload.
func NewUpdateGrpsioMailingListPayload(body *UpdateGrpsioMailingListRequestBody, uid string, version *string, bearerToken *string, ifMatch *string) *mailinglist.UpdateGrpsioMailingListPayload {
	v := &mailinglist.UpdateGrpsioMailingListPayload{
		GroupName:    *body.GroupName,
		Public:       *body.Public,
		Type:         *body.Type,
		CommitteeUID: body.CommitteeUID,
		Description:  *body.Description,
		Title:        *body.Title,
		SubjectTag:   body.SubjectTag,
		ServiceUID:   *body.ServiceUID,
	}
	if body.CommitteeFilters != nil {
		v.CommitteeFilters = make([]string, len(body.CommitteeFilters))
		for i, val := range body.CommitteeFilters {
			v.CommitteeFilters[i] = val
		}
	}
	if body.Writers != nil {
		v.Writers = make([]string, len(body.Writers))
		for i, val := range body.Writers {
			v.Writers[i] = val
		}
	}
	if body.Auditors != nil {
		v.Auditors = make([]string, len(body.Auditors))
		for i, val := range body.Auditors {
			v.Auditors[i] = val
		}
	}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// NewDeleteGrpsioMailingListPayload builds a mailing-list service
// delete-grpsio-mailing-list endpoint payload.
func NewDeleteGrpsioMailingListPayload(uid string, version *string, bearerToken *string, ifMatch *string) *mailinglist.DeleteGrpsioMailingListPayload {
	v := &mailinglist.DeleteGrpsioMailingListPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// ValidateCreateGrpsioServiceRequestBody runs the validations defined on
// Create-Grpsio-ServiceRequestBody
func ValidateCreateGrpsioServiceRequestBody(body *CreateGrpsioServiceRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.ProjectUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("project_uid", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "primary" || *body.Type == "formation" || *body.Type == "shared") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"primary", "formation", "shared"}))
		}
	}
	for _, e := range body.GlobalOwners {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.global_owners[*]", e, goa.FormatEmail))
	}
	if body.ProjectSlug != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_slug", *body.ProjectSlug, goa.FormatRegexp))
	}
	if body.ProjectSlug != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.project_slug", *body.ProjectSlug, "^[a-z][a-z0-9_\\-]*[a-z0-9]$"))
	}
	if body.ProjectUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", *body.ProjectUID, goa.FormatUUID))
	}
	if body.URL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.url", *body.URL, goa.FormatURI))
	}
	return
}

// ValidateUpdateGrpsioServiceRequestBody runs the validations defined on
// Update-Grpsio-ServiceRequestBody
func ValidateUpdateGrpsioServiceRequestBody(body *UpdateGrpsioServiceRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.ProjectUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("project_uid", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "primary" || *body.Type == "formation" || *body.Type == "shared") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"primary", "formation", "shared"}))
		}
	}
	for _, e := range body.GlobalOwners {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.global_owners[*]", e, goa.FormatEmail))
	}
	if body.ProjectSlug != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_slug", *body.ProjectSlug, goa.FormatRegexp))
	}
	if body.ProjectSlug != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.project_slug", *body.ProjectSlug, "^[a-z][a-z0-9_\\-]*[a-z0-9]$"))
	}
	if body.ProjectUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", *body.ProjectUID, goa.FormatUUID))
	}
	if body.URL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.url", *body.URL, goa.FormatURI))
	}
	return
}

// ValidateCreateGrpsioMailingListRequestBody runs the validations defined on
// Create-Grpsio-Mailing-ListRequestBody
func ValidateCreateGrpsioMailingListRequestBody(body *CreateGrpsioMailingListRequestBody) (err error) {
	if body.GroupName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("group_name", "body"))
	}
	if body.Public == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("public", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.ServiceUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("service_uid", "body"))
	}
	if body.GroupName != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.group_name", *body.GroupName, "^[a-zA-Z0-9][a-zA-Z0-9_-]*[a-zA-Z0-9]$"))
	}
	if body.GroupName != nil {
		if utf8.RuneCountInString(*body.GroupName) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.group_name", *body.GroupName, utf8.RuneCountInString(*body.GroupName), 3, true))
		}
	}
	if body.GroupName != nil {
		if utf8.RuneCountInString(*body.GroupName) > 34 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.group_name", *body.GroupName, utf8.RuneCountInString(*body.GroupName), 34, false))
		}
	}
	if body.Type != nil {
		if !(*body.Type == "announcement" || *body.Type == "discussion_moderated" || *body.Type == "discussion_open") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"announcement", "discussion_moderated", "discussion_open"}))
		}
	}
	if body.CommitteeUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.committee_uid", *body.CommitteeUID, goa.FormatUUID))
	}
	for _, e := range body.CommitteeFilters {
		if !(e == "Voting Rep" || e == "Alternate Voting Rep" || e == "Observer" || e == "Emeritus" || e == "None") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.committee_filters[*]", e, []any{"Voting Rep", "Alternate Voting Rep", "Observer", "Emeritus", "None"}))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) < 11 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 11, true))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 500 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 500, false))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) < 5 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 5, true))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 100, false))
		}
	}
	if body.SubjectTag != nil {
		if utf8.RuneCountInString(*body.SubjectTag) > 50 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.subject_tag", *body.SubjectTag, utf8.RuneCountInString(*body.SubjectTag), 50, false))
		}
	}
	if body.ServiceUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.service_uid", *body.ServiceUID, goa.FormatUUID))
	}
	return
}

// ValidateUpdateGrpsioMailingListRequestBody runs the validations defined on
// Update-Grpsio-Mailing-ListRequestBody
func ValidateUpdateGrpsioMailingListRequestBody(body *UpdateGrpsioMailingListRequestBody) (err error) {
	if body.GroupName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("group_name", "body"))
	}
	if body.Public == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("public", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.ServiceUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("service_uid", "body"))
	}
	if body.GroupName != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.group_name", *body.GroupName, "^[a-zA-Z0-9][a-zA-Z0-9_-]*[a-zA-Z0-9]$"))
	}
	if body.GroupName != nil {
		if utf8.RuneCountInString(*body.GroupName) < 3 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.group_name", *body.GroupName, utf8.RuneCountInString(*body.GroupName), 3, true))
		}
	}
	if body.GroupName != nil {
		if utf8.RuneCountInString(*body.GroupName) > 34 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.group_name", *body.GroupName, utf8.RuneCountInString(*body.GroupName), 34, false))
		}
	}
	if body.Type != nil {
		if !(*body.Type == "announcement" || *body.Type == "discussion_moderated" || *body.Type == "discussion_open") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"announcement", "discussion_moderated", "discussion_open"}))
		}
	}
	if body.CommitteeUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.committee_uid", *body.CommitteeUID, goa.FormatUUID))
	}
	for _, e := range body.CommitteeFilters {
		if !(e == "Voting Rep" || e == "Alternate Voting Rep" || e == "Observer" || e == "Emeritus" || e == "None") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.committee_filters[*]", e, []any{"Voting Rep", "Alternate Voting Rep", "Observer", "Emeritus", "None"}))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) < 11 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 11, true))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 500 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 500, false))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) < 5 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 5, true))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 100, false))
		}
	}
	if body.SubjectTag != nil {
		if utf8.RuneCountInString(*body.SubjectTag) > 50 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.subject_tag", *body.SubjectTag, utf8.RuneCountInString(*body.SubjectTag), 50, false))
		}
	}
	if body.ServiceUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.service_uid", *body.ServiceUID, goa.FormatUUID))
	}
	return
}
